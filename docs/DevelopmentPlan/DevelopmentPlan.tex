\documentclass{article}

\usepackage{booktabs}
\usepackage{tabularx}
\usepackage{float}

\title{Development Plan\\\progname}

\author{\authname}

\date{}

\input{../Comments}
\input{../Common}

\begin{document}

\begin{table}[hp]
\caption{Revision History} \label{TblRevisionHistory}
\begin{tabularx}{\textwidth}{llX}
\toprule
\textbf{Date} & \textbf{Developer(s)} & \textbf{Change}\\
\midrule
September 23, 2022 & Arkin Modi & Create project scheduling section\\
September 23, 2022 & Arkin Modi & Create workflow plan\\
September 23, 2022 & Arkin Modi & Create technology and code standard sections\\
\bottomrule
\end{tabularx}
\end{table}

\newpage

\maketitle

\wss{Put your introductory blurb here.}

\section{Team Meeting Plan}

\section{Team Communication Plan}

\section{Team Member Roles}

\section{Workflow Plan}

% \begin{itemize}
%   \item How will you be using git, including branches, pull request, etc.?
%   \item How will you be managing issues, including template issues, issue
%   classification, etc.?
% \end{itemize}

\subsection{Development Workflow}

The team will be using Git as their version control system and the repository will be hosted
publicly on GitHub. The most stable up-to-date version of our application will be on the ``main''
branch. The team will update the main branch using a feature branch workflow. The feature branch
workflow entails the developer to:

\begin{enumerate}
  \item Create a new feature branch
  \item Push changes to the new branch
  \item Open a pull request against the main branch
  \item Link the pull request to an issue (if appropriate)
  \item Add ``needs review'' label (if ready for review)
  \item Assign assignees and reviewers
  \item Pass any pull request pipelines in our CI/CD setup
  \item Receive reviews from other team members
  \item Address any comments or change requests
  \item Merge or close the pull request
\end{enumerate}

To prevent naming conflicts, the team will follow a branch naming convention of
``$<$GitHub username$>$/$<$branch name$>$''. The merge strategy used for pull requests will be
``squash and merge''. Using this merge strategy increases traceability on the main branch's commit
history by having every commit represented by a working/passing pull request and prevents adding
broken commits to the main branch's commit history.

All team members are listed as code owners of everything in the repository (defined in
.github/CODEOWNERS). GitHub will read this and automatically assigned all team members to every pull
request opened in the repository. Every pull request should receive, at minimum, one review before
merging.

\subsection{Project Management Workflow}

The team will be using GitHub's issue tracker and GitHub Projects to manage the project. The issue
tracker will track work that needs to be done. For each task that isn't trivial, an issue will be
open to track the contribution and progress. Examples of trivial tasks include spelling corrections,
dependency version updates, base repository template updates. Each issue will also be assigned to
team member who will then assume responsibility for said issue.

Labels, as described in Table \ref{issueLabels}, will used to organize issues. The GitHub Project
board will be used to visualize the progress of each issue and track overall progress.

\begin{table}[H]
  \centering
  \caption{Issue Labels}
  \vspace{5pt}
  \begin{tabular}{|p{0.2\textwidth}|p{0.7\textwidth}|}
      \hline
      \textbf{Name} & \textbf{Description}\\
      \hline
      documentation & These issues are related to documentation or reports for course deliverables.\\
      \hline
      Epic & These issues are tracking a collection of other issues. For example, an issues a report
      has sub-issues for each section.\\
      \hline
      meeting needed & A team meeting is needed to discuss details related to the issue.\\
      \hline
      meeting notes & This issue contains notes from a completed meeting.\\
      \hline
      needs breakdown & This issue needs further breakdown into smaller issues/steps.\\
      \hline
      tech foundation & This issue is not contributing towards any course deliverables.\\
      \hline
  \end{tabular}

  \label{issueLabels}
\end{table}


\section{Proof of Concept Demonstration Plan}

What is the main risk, or risks, for the success of your project?  What will you
demonstrate during your proof of concept demonstration to convince yourself that
you will be able to overcome this risk?

\section{Technology}

% \begin{itemize}
%   \item Specific programming language
%   \item Specific linter tool (if appropriate)
%   \item Specific unit testing framework
%   \item Investigation of code coverage measuring tools
%   \item Specific plans for Continuous Integration (CI), or an explanation that CI is not being
%   done
%   \item Specific performance measuring tools (like Valgrind), if appropriate
%   \item Libraries you will likely be using?
%   \item Tools you will likely be using?
% \end{itemize}

The project will written in TypeScript using the Next.js framework. Next.js is a React framework
that provides both a frontend and a backend interface. The team is comfortable with React and with
both the core Next.js team and the core React team recommending Next.js for
``production-ready projects'', we see this as a good choice. We will be using NPM as our package
manager and the packages next-auth and next-pwa. NextAuth is a package built for Next.js to quickly
enable authentication with many out of the box adaptors for providers and databases. Next-PWA is a
package to quickly enable the creating of Progressive Web App (PWA)'s in Next.js. We have decided to
create a PWA since this was one of the key application attributes that the supervisor required.

For our user interface, we have chose to use Blueprint JS as our component library along side CSS. A
team member has previous experience with this library and recommended using it.

We will be using Prisma as our ORM (Object-relational mapping) and MySQL as our database management
system. We have decided to use a SQL database due to our data having relations. MySQL was
specifically chosen due to past experience within the team. In a NoSQL database, relations are
harder to maintain and/or possibly inefficient to query. SQL databases also provide the assurances
of ACID compliance, fewer consistency issues, and enforced field constraints. The use of Prisma is
due to past experience within the team and a strong reputation within the web development world.

Jest and React Testing Library will be used for our unit tests, integration tests, and code
coverage. Most of the team does not have much experience with frontend testing, therefore we have
decided to go with the libraries recommended by Next.js. We have decided against using any
end-to-end testing frameworks (e.g., Cypress, Playwright) due to lack of domain knowledge within the
team and time constraints.

Git and GitHub will be used for version control and hosting a centralized online repository. This
was chosen due to course requirements and past experience.

Documentation will be written in a mix of \LaTeX{} and Markdown.

With high performance not being a primary goal with this project, we will not use using any
performance benchmarking tools. We will be maintaining a Google Lighthouse score of greater than
90\%.

All CI/CD pipelines will be created using GitHub Actions. This was chosen due to GitHub Actions
having great integration with GitHub, a generous free and pro tier, past experience within the team,
and ease of use.

The development environment for any developer is a highly personal decision and while we will not be
enforcing the use any specific local dev tooling, we will be recommending to all developers to use
Visual Studio Code for easy interoperability between developers. We will also have a list of
recommended extensions and setting for Visual Studio Code available in the .vscode folder. We will
also be using Docker for easy setup of external dependencies (e.g., TeX Live, MySQL).

\section{Coding Standard}

To ensure consistent code styling and code quality, the application code will be formatted using
Prettier. Prettier is an industry standard code formatter and widely agreed upon default
configuration.

For our \LaTeX{} docs, we will be using latexindent.pl. latexindent.pl is a popular \LaTeX{} code
formatter. The primary use will be for managing our whitespace to ensure consistent readability in
our source files. The primary reason behind this choice was latexindent.pl's code formatter
capabilities to automatically apply fixes.

\section{Project Scheduling}

% \wss{How will the project be scheduled?}

The project schedule will primarily follow the course calendar with development of the application
starting in October 2022. Progress of the project will be tracked using a GitHub Project board. The
deliverables due date will act as our milestones.

Decomposition of large tasks into smaller tasks for documentation deliverables will done by breaking
down the reports by section. Sections will be determined by consulting provided templates, rubrics,
and examples. Breaking large development tasks into smaller tasks will be done by first researching
and scoping out how the task should be architected. Following this initial architecture, smaller
tasks will be created.

Responsibility/ownership of tasks will be decided as a team during weekly meetings or offline
communications. It is upon each member to communicate their availability and capable workload.
Ideally, the work shall be equally distributed over the course of the project, but a shift in
workloads on an individual deliverable basis is expected. If a member is unable to complete a task
they are assigned, it is their responsibility to communicate this to the team and have the task
reassigned. The expectation is each member shall contribute an average of 10 hours per week.

\end{document}
